<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Advanced Particle Simulator</title>
<style>
  body {
    margin: 0; overflow: hidden;
    background-color: #121217;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: #0ff;
    display: flex;
  }
  #sidebar {
    width: 280px;
    background: #222;
    padding: 15px;
    box-sizing: border-box;
    overflow-y: auto;
    height: 100vh;
  }
  #sidebar h2 {
    margin-top: 0;
    color: #0ff;
    text-align: center;
  }
  label {
    display: block;
    margin: 10px 0 4px;
    font-size: 0.9rem;
  }
  input[type="range"], select, input[type="color"] {
    width: 100%;
    margin-bottom: 10px;
  }
  button {
    background: #0ff;
    border: none;
    padding: 10px;
    margin: 5px 0;
    cursor: pointer;
    font-weight: bold;
    color: #111;
    width: 100%;
    border-radius: 4px;
  }
  canvas {
    flex: 1;
    display: block;
  }
</style>
</head>
<body>

<div id="sidebar">
  <h2>Particle Settings</h2>

  <label for="quantity">Quantity</label>
  <input id="quantity" type="range" min="100" max="5000" value="1000" step="100" />

  <label for="size">Size</label>
  <input id="size" type="range" min="1" max="20" value="5" />

  <label for="speed">Speed</label>
  <input id="speed" type="range" min="0" max="10" value="2" step="0.1" />

  <label for="lifetime">Lifetime (seconds)</label>
  <input id="lifetime" type="range" min="1" max="30" value="15" />

  <label for="shape">Shape</label>
  <select id="shape">
    <option value="circle">Circle</option>
    <option value="square">Square</option>
    <option value="star">Star</option>
  </select>

  <label for="interaction">Interaction Mode</label>
  <select id="interaction">
    <option value="static">Static</option>
    <option value="attract">Attract</option>
    <option value="repel">Repel</option>
    <option value="swirl">Swirl</option>
  </select>

  <label for="colorMode">Color Mode</label>
  <select id="colorMode">
    <option value="fixed">Fixed</option>
    <option value="gradient">Gradient</option>
    <option value="rainbow">Rainbow</option>
  </select>

  <label for="fixedColor">Fixed Color</label>
  <input id="fixedColor" type="color" value="#00ffff" />

  <label for="gradientStart">Gradient Start</label>
  <input id="gradientStart" type="color" value="#00ffff" />

  <label for="gradientEnd">Gradient End</label>
  <input id="gradientEnd" type="color" value="#ff00ff" />

  <button id="pauseBtn">Pause</button>
  <button id="resetBtn">Reset</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
(() => {
  // Get UI elements
  const quantityInput = document.getElementById('quantity');
  const sizeInput = document.getElementById('size');
  const speedInput = document.getElementById('speed');
  const lifetimeInput = document.getElementById('lifetime');
  const shapeSelect = document.getElementById('shape');
  const interactionSelect = document.getElementById('interaction');
  const colorModeSelect = document.getElementById('colorMode');
  const fixedColorInput = document.getElementById('fixedColor');
  const gradientStartInput = document.getElementById('gradientStart');
  const gradientEndInput = document.getElementById('gradientEnd');
  const pauseBtn = document.getElementById('pauseBtn');
  const resetBtn = document.getElementById('resetBtn');

  // Setup Three.js basics
  const canvasWidth = window.innerWidth - 280;
  const canvasHeight = window.innerHeight;
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, canvasWidth / canvasHeight, 0.1, 1000);
  camera.position.z = 400;

  const renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(canvasWidth, canvasHeight);
  renderer.setClearColor(0x121217);
  document.body.appendChild(renderer.domElement);
  renderer.domElement.style.marginLeft = '280px';

  // Particle data arrays
  let particles;
  let geometry;
  let material;

  let particleCount = +quantityInput.value;
  let particleSize = +sizeInput.value;
  let particleSpeed = +speedInput.value;
  let particleLifetime = +lifetimeInput.value;
  let interactionMode = interactionSelect.value;
  let colorMode = colorModeSelect.value;
  let fixedColor = new THREE.Color(fixedColorInput.value);
  let gradientStart = new THREE.Color(gradientStartInput.value);
  let gradientEnd = new THREE.Color(gradientEndInput.value);
  let paused = false;

  // Particle custom data arrays for positions, velocities, ages
  let positions = new Float32Array(particleCount * 3);
  let velocities = new Float32Array(particleCount * 3);
  let ages = new Float32Array(particleCount);

  // For coloring
  let colors = new Float32Array(particleCount * 3);

  // Mouse tracking
  let mouse = { x: 0, y: 0 };
  window.addEventListener('mousemove', e => {
    mouse.x = e.clientX - 280 - canvasWidth/2;
    mouse.y = - (e.clientY - canvasHeight/2);
  });

  // Create texture for particle shapes
  function createParticleTexture(shape) {
    const size = 64;
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = size;
    const ctx = canvas.getContext('2d');

    ctx.clearRect(0, 0, size, size);
    ctx.fillStyle = 'white';

    if(shape === 'circle') {
      ctx.beginPath();
      ctx.arc(size/2, size/2, size/3, 0, Math.PI*2);
      ctx.fill();
    } else if(shape === 'square') {
      const s = size * 0.6;
      ctx.fillRect((size - s)/2, (size - s)/2, s, s);
    } else if(shape === 'star') {
      const cx = size/2;
      const cy = size/2;
      const spikes = 5;
      const outerRadius = size/3;
      const innerRadius = size/6;
      let rot = Math.PI / 2 * 3;
      let x = cx;
      let y = cy;
      const step = Math.PI / spikes;

      ctx.beginPath();
      ctx.moveTo(cx, cy - outerRadius);
      for(let i = 0; i < spikes; i++) {
        x = cx + Math.cos(rot) * outerRadius;
        y = cy + Math.sin(rot) * outerRadius;
        ctx.lineTo(x, y);
        rot += step;

        x = cx + Math.cos(rot) * innerRadius;
        y = cy + Math.sin(rot) * innerRadius;
        ctx.lineTo(x, y);
        rot += step;
      }
      ctx.lineTo(cx, cy - outerRadius);
      ctx.closePath();
      ctx.fill();
    }

    return new THREE.CanvasTexture(canvas);
  }

  // Initialize particles buffers
  function initParticles() {
    particleCount = +quantityInput.value;
    particleSize = +sizeInput.value;
    particleSpeed = +speedInput.value;
    particleLifetime = +lifetimeInput.value;
    interactionMode = interactionSelect.value;
    colorMode = colorModeSelect.value;
    fixedColor.set(fixedColorInput.value);
    gradientStart.set(gradientStartInput.value);
    gradientEnd.set(gradientEndInput.value);

    positions = new Float32Array(particleCount * 3);
    velocities = new Float32Array(particleCount * 3);
    ages = new Float32Array(particleCount);
    colors = new Float32Array(particleCount * 3);

    // Initialize positions, velocities, colors
    for(let i=0; i<particleCount; i++) {
      positions[i*3] = (Math.random() - 0.5) * canvasWidth;
      positions[i*3+1] = (Math.random() - 0.5) * canvasHeight;
      positions[i*3+2] = 0;

      velocities[i*3] = (Math.random() - 0.5) * particleSpeed;
      velocities[i*3+1] = (Math.random() - 0.5) * particleSpeed;
      velocities[i*3+2] = 0;

      ages[i] = Math.random() * particleLifetime;

      colors[i*3] = fixedColor.r;
      colors[i*3+1] = fixedColor.g;
      colors[i*3+2] = fixedColor.b;
    }

    if(particles) {
      scene.remove(particles);
      geometry.dispose();
      material.dispose();
    }

    geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    material = new THREE.PointsMaterial({
      size: particleSize,
      vertexColors: true,
      map: createParticleTexture(shapeSelect.value),
      transparent: true,
      alphaTest: 0.1,
      depthWrite: false,
      sizeAttenuation: true,
    });

    particles = new THREE.Points(geometry, material);
    scene.add(particles);
  }

  // Update particle colors based on mode and time
  function updateColors(time) {
    if(colorMode === 'fixed') {
      for(let i=0; i<particleCount; i++) {
        colors[i*3] = fixedColor.r;
        colors[i*3+1] = fixedColor.g;
        colors[i*3+2] = fixedColor.b;
      }
    } else if(colorMode === 'gradient') {
      for(let i=0; i<particleCount; i++) {
        const yNorm = (positions[i*3+1] + canvasHeight/2) / canvasHeight;
        colors[i*3] = THREE.MathUtils.lerp(gradientStart.r, gradientEnd.r, yNorm);
        colors[i*3+1] = THREE.MathUtils.lerp(gradientStart.g, gradientEnd.g, yNorm);
        colors[i*3+2] = THREE.MathUtils.lerp(gradientStart.b, gradientEnd.b, yNorm);
      }
    } else if(colorMode === 'rainbow') {
      for(let i=0; i<particleCount; i++) {
        const hue = ((time * 0.1) + i / particleCount) % 1;
        const color = new THREE.Color();
        color.setHSL(hue, 1, 0.5);
        colors[i*3] = color.r;
        colors[i*3+1] = color.g;
        colors[i*3+2] = color.b;
      }
    }
    geometry.attributes.color.needsUpdate = true;
  }

  // Particle physics and interaction
  function updateParticles(delta) {
    for(let i=0; i<particleCount; i++) {
      ages[i] += delta;
      if(ages[i] > particleLifetime) {
        // Respawn particle randomly inside canvas
        positions[i*3] = (Math.random() - 0.5) * canvasWidth;
        positions[i*3+1] = (Math.random() - 0.5) * canvasHeight;
        velocities[i*3] = (Math.random() - 0.5) * particleSpeed;
        velocities[i*3+1] = (Math.random() - 0.5) * particleSpeed;
        ages[i] = 0;
      }

      const dx = mouse.x - positions[i*3];
      const dy = mouse.y - positions[i*3+1];
      const dist = Math.sqrt(dx*dx + dy*dy);

      if(interactionMode !== 'static' && dist < 150 && dist > 0) {
        const nx = dx / dist;
        const ny = dy / dist;
        switch(interactionMode) {
          case 'attract':
            velocities[i*3] += nx * delta * 50;
            velocities[i*3+1] += ny * delta * 50;
            break;
          case 'repel':
            velocities[i*3] -= nx * delta * 50;
            velocities[i*3+1] -= ny * delta * 50;
            break;
          case 'swirl':
            velocities[i*3] += ny * delta * 50;
            velocities[i*3+1] -= nx * delta * 50;
            break;
        }
      }

      // Simple friction
      velocities[i*3] *= 0.95;
      velocities[i*3+1] *= 0.95;

      // Update positions
      positions[i*3] += velocities[i*3] * delta * 60;
      positions[i*3+1] += velocities[i*3+1] * delta * 60;

      // Wrap around edges
      if(positions[i*3] < -canvasWidth/2) positions[i*3] += canvasWidth;
      if(positions[i*3] > canvasWidth/2) positions[i*3] -= canvasWidth;
      if(positions[i*3+1] < -canvasHeight/2) positions[i*3+1] += canvasHeight;
      if(positions[i*3+1] > canvasHeight/2) positions[i*3+1] -= canvasHeight;
    }
    geometry.attributes.position.needsUpdate = true;
  }

  let lastTime = performance.now();

  function animate() {
    if(!paused) {
      const now = performance.now();
      const delta = (now - lastTime) / 1000;
      lastTime = now;

      updateParticles(delta);
      updateColors(now / 1000);
      renderer.render(scene, camera);
    }
    requestAnimationFrame(animate);
  }

  // UI event listeners
  quantityInput.addEventListener('input', initParticles);
  sizeInput.addEventListener('input', () => {
    particleSize = +sizeInput.value;
    if(material) material.size = particleSize;
  });
  speedInput.addEventListener('input', () => {
    particleSpeed = +speedInput.value;
  });
  lifetimeInput.addEventListener('input', () => {
    particleLifetime = +lifetimeInput.value;
  });
  interactionSelect.addEventListener('change', () => {
    interactionMode = interactionSelect.value;
  });
  colorModeSelect.addEventListener('change', () => {
    colorMode = colorModeSelect.value;
  });
  fixedColorInput.addEventListener('input', () => {
    fixedColor.set(fixedColorInput.value);
  });
  gradientStartInput.addEventListener('input', () => {
    gradientStart.set(gradientStartInput.value);
  });
  gradientEndInput.addEventListener('input', () => {
    gradientEnd.set(gradientEndInput.value);
  });
  shapeSelect.addEventListener('change', () => {
    if(material) {
      material.map = createParticleTexture(shapeSelect.value);
      material.needsUpdate = true;
    }
  });

  pauseBtn.addEventListener('click', () => {
    paused = !paused;
    pauseBtn.textContent = paused ? 'Resume' : 'Pause';
  });

  resetBtn.addEventListener('click', () => {
    initParticles();
  });

  // Handle window resize
  window.addEventListener('resize', () => {
    const newWidth = window.innerWidth - 280;
    const newHeight = window.innerHeight;
    renderer.setSize(newWidth, newHeight);
    camera.aspect = newWidth / newHeight;
    camera.updateProjectionMatrix();
  });

  // Initialize and start
  initParticles();
  animate();

})();
</script>
</body>
</html>
